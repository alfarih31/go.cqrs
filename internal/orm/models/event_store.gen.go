// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package models

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/jetbasrawi/go.cqrs/internal/orm/model"
)

func newEventStore(db *gorm.DB, opts ...gen.DOOption) eventStore {
	_eventStore := eventStore{}

	_eventStore.eventStoreDo.UseDB(db, opts...)
	_eventStore.eventStoreDo.UseModel(&model.EventStore{})

	tableName := _eventStore.eventStoreDo.TableName()
	_eventStore.ALL = field.NewAsterisk(tableName)
	_eventStore.ID = field.NewInt64(tableName, "id")
	_eventStore.EventID = field.NewString(tableName, "event_id")
	_eventStore.EventName = field.NewString(tableName, "event_name")
	_eventStore.EventData = field.NewString(tableName, "event_data")
	_eventStore.Metadata = field.NewString(tableName, "metadata")
	_eventStore.CreatedAt = field.NewTime(tableName, "created_at")
	_eventStore.EventStreams = eventStoreHasManyEventStreams{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("EventStreams", "model.EventStream"),
		Event: struct {
			field.RelationField
			EventStreams struct {
				field.RelationField
				Event struct {
					field.RelationField
				}
			}
		}{
			RelationField: field.NewRelation("EventStreams.Event", "model.EventStore"),
			EventStreams: struct {
				field.RelationField
				Event struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("EventStreams.Event.EventStreams", "model.EventStream"),
				Event: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("EventStreams.Event.EventStreams.Event", "model.EventStore"),
				},
			},
		},
	}

	_eventStore.fillFieldMap()

	return _eventStore
}

type eventStore struct {
	eventStoreDo

	ALL          field.Asterisk
	ID           field.Int64
	EventID      field.String
	EventName    field.String
	EventData    field.String
	Metadata     field.String
	CreatedAt    field.Time
	EventStreams eventStoreHasManyEventStreams

	fieldMap map[string]field.Expr
}

func (e eventStore) Table(newTableName string) *eventStore {
	e.eventStoreDo.UseTable(newTableName)
	return e.updateTableName(newTableName)
}

func (e eventStore) As(alias string) *eventStore {
	e.eventStoreDo.DO = *(e.eventStoreDo.As(alias).(*gen.DO))
	return e.updateTableName(alias)
}

func (e *eventStore) updateTableName(table string) *eventStore {
	e.ALL = field.NewAsterisk(table)
	e.ID = field.NewInt64(table, "id")
	e.EventID = field.NewString(table, "event_id")
	e.EventName = field.NewString(table, "event_name")
	e.EventData = field.NewString(table, "event_data")
	e.Metadata = field.NewString(table, "metadata")
	e.CreatedAt = field.NewTime(table, "created_at")

	e.fillFieldMap()

	return e
}

func (e *eventStore) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := e.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (e *eventStore) fillFieldMap() {
	e.fieldMap = make(map[string]field.Expr, 7)
	e.fieldMap["id"] = e.ID
	e.fieldMap["event_id"] = e.EventID
	e.fieldMap["event_name"] = e.EventName
	e.fieldMap["event_data"] = e.EventData
	e.fieldMap["metadata"] = e.Metadata
	e.fieldMap["created_at"] = e.CreatedAt

}

func (e eventStore) clone(db *gorm.DB) eventStore {
	e.eventStoreDo.ReplaceConnPool(db.Statement.ConnPool)
	return e
}

func (e eventStore) replaceDB(db *gorm.DB) eventStore {
	e.eventStoreDo.ReplaceDB(db)
	return e
}

type eventStoreHasManyEventStreams struct {
	db *gorm.DB

	field.RelationField

	Event struct {
		field.RelationField
		EventStreams struct {
			field.RelationField
			Event struct {
				field.RelationField
			}
		}
	}
}

func (a eventStoreHasManyEventStreams) Where(conds ...field.Expr) *eventStoreHasManyEventStreams {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a eventStoreHasManyEventStreams) WithContext(ctx context.Context) *eventStoreHasManyEventStreams {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a eventStoreHasManyEventStreams) Model(m *model.EventStore) *eventStoreHasManyEventStreamsTx {
	return &eventStoreHasManyEventStreamsTx{a.db.Model(m).Association(a.Name())}
}

type eventStoreHasManyEventStreamsTx struct{ tx *gorm.Association }

func (a eventStoreHasManyEventStreamsTx) Find() (result []*model.EventStream, err error) {
	return result, a.tx.Find(&result)
}

func (a eventStoreHasManyEventStreamsTx) Append(values ...*model.EventStream) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a eventStoreHasManyEventStreamsTx) Replace(values ...*model.EventStream) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a eventStoreHasManyEventStreamsTx) Delete(values ...*model.EventStream) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a eventStoreHasManyEventStreamsTx) Clear() error {
	return a.tx.Clear()
}

func (a eventStoreHasManyEventStreamsTx) Count() int64 {
	return a.tx.Count()
}

type eventStoreDo struct{ gen.DO }

type IEventStoreDo interface {
	gen.SubQuery
	Debug() IEventStoreDo
	WithContext(ctx context.Context) IEventStoreDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IEventStoreDo
	WriteDB() IEventStoreDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IEventStoreDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IEventStoreDo
	Not(conds ...gen.Condition) IEventStoreDo
	Or(conds ...gen.Condition) IEventStoreDo
	Select(conds ...field.Expr) IEventStoreDo
	Where(conds ...gen.Condition) IEventStoreDo
	Order(conds ...field.Expr) IEventStoreDo
	Distinct(cols ...field.Expr) IEventStoreDo
	Omit(cols ...field.Expr) IEventStoreDo
	Join(table schema.Tabler, on ...field.Expr) IEventStoreDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IEventStoreDo
	RightJoin(table schema.Tabler, on ...field.Expr) IEventStoreDo
	Group(cols ...field.Expr) IEventStoreDo
	Having(conds ...gen.Condition) IEventStoreDo
	Limit(limit int) IEventStoreDo
	Offset(offset int) IEventStoreDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IEventStoreDo
	Unscoped() IEventStoreDo
	Create(values ...*model.EventStore) error
	CreateInBatches(values []*model.EventStore, batchSize int) error
	Save(values ...*model.EventStore) error
	First() (*model.EventStore, error)
	Take() (*model.EventStore, error)
	Last() (*model.EventStore, error)
	Find() ([]*model.EventStore, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.EventStore, err error)
	FindInBatches(result *[]*model.EventStore, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.EventStore) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IEventStoreDo
	Assign(attrs ...field.AssignExpr) IEventStoreDo
	Joins(fields ...field.RelationField) IEventStoreDo
	Preload(fields ...field.RelationField) IEventStoreDo
	FirstOrInit() (*model.EventStore, error)
	FirstOrCreate() (*model.EventStore, error)
	FindByPage(offset int, limit int) (result []*model.EventStore, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IEventStoreDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (e eventStoreDo) Debug() IEventStoreDo {
	return e.withDO(e.DO.Debug())
}

func (e eventStoreDo) WithContext(ctx context.Context) IEventStoreDo {
	return e.withDO(e.DO.WithContext(ctx))
}

func (e eventStoreDo) ReadDB() IEventStoreDo {
	return e.Clauses(dbresolver.Read)
}

func (e eventStoreDo) WriteDB() IEventStoreDo {
	return e.Clauses(dbresolver.Write)
}

func (e eventStoreDo) Session(config *gorm.Session) IEventStoreDo {
	return e.withDO(e.DO.Session(config))
}

func (e eventStoreDo) Clauses(conds ...clause.Expression) IEventStoreDo {
	return e.withDO(e.DO.Clauses(conds...))
}

func (e eventStoreDo) Returning(value interface{}, columns ...string) IEventStoreDo {
	return e.withDO(e.DO.Returning(value, columns...))
}

func (e eventStoreDo) Not(conds ...gen.Condition) IEventStoreDo {
	return e.withDO(e.DO.Not(conds...))
}

func (e eventStoreDo) Or(conds ...gen.Condition) IEventStoreDo {
	return e.withDO(e.DO.Or(conds...))
}

func (e eventStoreDo) Select(conds ...field.Expr) IEventStoreDo {
	return e.withDO(e.DO.Select(conds...))
}

func (e eventStoreDo) Where(conds ...gen.Condition) IEventStoreDo {
	return e.withDO(e.DO.Where(conds...))
}

func (e eventStoreDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IEventStoreDo {
	return e.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (e eventStoreDo) Order(conds ...field.Expr) IEventStoreDo {
	return e.withDO(e.DO.Order(conds...))
}

func (e eventStoreDo) Distinct(cols ...field.Expr) IEventStoreDo {
	return e.withDO(e.DO.Distinct(cols...))
}

func (e eventStoreDo) Omit(cols ...field.Expr) IEventStoreDo {
	return e.withDO(e.DO.Omit(cols...))
}

func (e eventStoreDo) Join(table schema.Tabler, on ...field.Expr) IEventStoreDo {
	return e.withDO(e.DO.Join(table, on...))
}

func (e eventStoreDo) LeftJoin(table schema.Tabler, on ...field.Expr) IEventStoreDo {
	return e.withDO(e.DO.LeftJoin(table, on...))
}

func (e eventStoreDo) RightJoin(table schema.Tabler, on ...field.Expr) IEventStoreDo {
	return e.withDO(e.DO.RightJoin(table, on...))
}

func (e eventStoreDo) Group(cols ...field.Expr) IEventStoreDo {
	return e.withDO(e.DO.Group(cols...))
}

func (e eventStoreDo) Having(conds ...gen.Condition) IEventStoreDo {
	return e.withDO(e.DO.Having(conds...))
}

func (e eventStoreDo) Limit(limit int) IEventStoreDo {
	return e.withDO(e.DO.Limit(limit))
}

func (e eventStoreDo) Offset(offset int) IEventStoreDo {
	return e.withDO(e.DO.Offset(offset))
}

func (e eventStoreDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IEventStoreDo {
	return e.withDO(e.DO.Scopes(funcs...))
}

func (e eventStoreDo) Unscoped() IEventStoreDo {
	return e.withDO(e.DO.Unscoped())
}

func (e eventStoreDo) Create(values ...*model.EventStore) error {
	if len(values) == 0 {
		return nil
	}
	return e.DO.Create(values)
}

func (e eventStoreDo) CreateInBatches(values []*model.EventStore, batchSize int) error {
	return e.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (e eventStoreDo) Save(values ...*model.EventStore) error {
	if len(values) == 0 {
		return nil
	}
	return e.DO.Save(values)
}

func (e eventStoreDo) First() (*model.EventStore, error) {
	if result, err := e.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.EventStore), nil
	}
}

func (e eventStoreDo) Take() (*model.EventStore, error) {
	if result, err := e.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.EventStore), nil
	}
}

func (e eventStoreDo) Last() (*model.EventStore, error) {
	if result, err := e.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.EventStore), nil
	}
}

func (e eventStoreDo) Find() ([]*model.EventStore, error) {
	result, err := e.DO.Find()
	return result.([]*model.EventStore), err
}

func (e eventStoreDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.EventStore, err error) {
	buf := make([]*model.EventStore, 0, batchSize)
	err = e.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (e eventStoreDo) FindInBatches(result *[]*model.EventStore, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return e.DO.FindInBatches(result, batchSize, fc)
}

func (e eventStoreDo) Attrs(attrs ...field.AssignExpr) IEventStoreDo {
	return e.withDO(e.DO.Attrs(attrs...))
}

func (e eventStoreDo) Assign(attrs ...field.AssignExpr) IEventStoreDo {
	return e.withDO(e.DO.Assign(attrs...))
}

func (e eventStoreDo) Joins(fields ...field.RelationField) IEventStoreDo {
	for _, _f := range fields {
		e = *e.withDO(e.DO.Joins(_f))
	}
	return &e
}

func (e eventStoreDo) Preload(fields ...field.RelationField) IEventStoreDo {
	for _, _f := range fields {
		e = *e.withDO(e.DO.Preload(_f))
	}
	return &e
}

func (e eventStoreDo) FirstOrInit() (*model.EventStore, error) {
	if result, err := e.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.EventStore), nil
	}
}

func (e eventStoreDo) FirstOrCreate() (*model.EventStore, error) {
	if result, err := e.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.EventStore), nil
	}
}

func (e eventStoreDo) FindByPage(offset int, limit int) (result []*model.EventStore, count int64, err error) {
	result, err = e.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = e.Offset(-1).Limit(-1).Count()
	return
}

func (e eventStoreDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = e.Count()
	if err != nil {
		return
	}

	err = e.Offset(offset).Limit(limit).Scan(result)
	return
}

func (e eventStoreDo) Scan(result interface{}) (err error) {
	return e.DO.Scan(result)
}

func (e eventStoreDo) Delete(models ...*model.EventStore) (result gen.ResultInfo, err error) {
	return e.DO.Delete(models)
}

func (e *eventStoreDo) withDO(do gen.Dao) *eventStoreDo {
	e.DO = *do.(*gen.DO)
	return e
}
